import os

import rclpy
from rclpy.node import Node
from rclpy.qos import qos_profile_services_default, qos_profile_system_default

from ament_index_python import get_package_share_directory

from ros2node.api import get_node_names, NodeName

from tf2_ros.transform_listener import TransformListener
from tf2_ros import Buffer

from tf_transformations import euler_matrix

import numpy as np

import yaml

from riptide_msgs2.msg import DshotPartialTelemetry, KillSwitchReport, DshotCommand
from nav_msgs.msg import Odometry
from rcl_interfaces.srv import SetParameters
from rcl_interfaces.msg import Parameter, ParameterValue, ParameterType
from std_msgs.msg import Int16, Int32MultiArray, Float32MultiArray
from rclpy.time import Time

ERROR_PATIENCE = 1.0

PARAMETER_SCALE = 1000000

THRUSTER_SOLVER_WRENCH_MATRIX_PARAM = "talos_wrenchmat"
THRUSTER_SOLVER_WEIGHT_MATRIX_TOPIC = "controller/solver_weights"
THRUSTER_SOLVER_SYSTEM_LIMIT_PARAM = "talos_sys_lim"
THRUSTER_SOLVER_INDIVIDUAL_LIMIT_PARAM = "talos_indiv_lim"
THRUSTER_SOLVER_SCALING_PARAM = "thruster_solver_scaling_parameters"
THRUSTER_SOLVER_FORCE_RPM_COEFFICENTS_PARAM = "talos_force_curve_coefficents"
THRUSTER_SOLVER_DISABLE_WEIGHTS = "thruster_solver_disable_weight"

FF_CONTROLLER_COM_PARAM = "COB"
FF_CONTROLLER_COB_PARAM = "COM"
FF_CONTROLLER_BUOYANT_FORCE_PARAM = "Buoyant_Force"
FF_CONTROLLER_MASS_PARAM = "Mass"
FF_CONTROLLER_SCALING_PARAM = "Scaling_Paramter"
FF_CONTROLLER_YAW_COMPENSATION_PARAM = "Yaw_Compensation"

RPM_PUBLISH_PERIOD = .02

G = 9.8067

#manages parameters for the controller / thruster solver
class controllerOverseer(Node):

    def __init__(self):
        super().__init__("controllerOverseer")

        #get robot name 
        self.declare_parameter("robot", "")
        self.robotName = self.get_parameter("robot").value

        #get robot config file path
        self.declare_parameter("vehicle_config", "")
        config_path = self.get_parameter("vehicle_config").value

        #get thruster solver node name
        self.declare_parameter("thruster_solver_node_name", "")
        self.thrusterSolverName = self.get_parameter("thruster_solver_node_name").value

        #get the ff controller node name
        self.declare_parameter("ff_controller_node_name", "")
        self.ffControllerName = self.get_parameter("ff_controller_node_name").value

        if(config_path == ''):
            #remove before running on robot
            config_path = os.path.join(get_package_share_directory("riptide_descriptions2"), "config", "talos.yaml")

            #self.get_logger().fatal("Controller Overseer: cannot find vehicle configuration file!")

        #open configuration file
        with open(config_path, "r") as config:
            config_file = yaml.safe_load(config)

        #read in kill plane height
        self.killPlane = config_file["controller_overseer"]["thruster_kill_plane"]

        #read in thruster pose data
        thruster_info = config_file['thrusters']

        #read in com data
        com = config_file["com"]

        #generate the thruster effect matrix
        self.thrusterEffects = np.zeros(shape=(8,6))
        for i, thruster in enumerate(thruster_info):
            pose = np.array(thruster["pose"])

            #calculate the force vector generated by the thruster
            forceVector = np.matmul(euler_matrix(pose[3], pose[4], pose[5])[:3, :3], np.array([1,0,0]))
            positionFromCOM = pose[:3] - com
            torque = np.cross(positionFromCOM[:3], forceVector)

            #insert into thruster effect matrix
            self.thrusterEffects[i] = [forceVector[0], forceVector[1], forceVector[2], torque[0], torque[1], torque[2]]

        #read in coefficents
        thruster_solver_info = config_file["thruster_solver"]
        self.forceToRPMCoefficents = thruster_solver_info["force_to_rpm_coefficents"]

        #read in weight info
        self.defaultWeight = thruster_solver_info["default_weight"]
        self.surfaceWeight = thruster_solver_info["surfaced_weight"]
        self.disabledWeight = thruster_solver_info["disable_weight"]
        self.lowDowndraftWeight = thruster_solver_info["low_downdraft_weight"]

        #read in solver limit params
        self.systemThrustLimit = thruster_solver_info["system_thrust_limit"]
        self.individualThrustLimit = thruster_solver_info["individual_thrust_limit"]

        #read in ff properties
        self.talos_mass = config_file["mass"]
        self.talos_COM = config_file["com"]
        self.talos_base_wrench = config_file["controller"]["feed_forward"]["base_wrench"]
        self.talos_face_up_wrench = config_file["controller"]["feed_forward"]["face_up_wrench"]

        #default thruster weights and working thrusters
        self.activeThrusters = [True, True, True, True, True, True, True, True]
        self.submerdgedThrusters = [True, True, True, True, True, True, True, True]
        self.thrusterWeights = [1,1,1,1,1,1,1,1]

        # the thruster mode
        self.thrusterMode = 1

        #declare pubs and subs

        #thruster telemetry
        self.create_subscription(DshotPartialTelemetry, "state/thrusters/telemetry", self.thrusterTelemetryCB, qos_profile_system_default)
        
        #thruster solver parameters
        self.setThrusterSolverParamsClient = self.create_client(SetParameters, f"{self.thrusterSolverName}/set_parameters")

        #FF controller parameters
        self.setFFControllerParamsClient = self.create_client(SetParameters, f"{self.ffControllerName}/set_parameters")

        #thruster mode
        self.create_subscription(Int16, "thrusterSolver/thrusterState", self.setThrusterModeCB, qos_profile_system_default)

        #odometry filtered
        self.create_subscription(Odometry, "odometry/filtered", self.odometryCB, qos_profile_system_default)

        #republish matlab to firmware
        #TODO remove
        self.create_subscription(Int32MultiArray, "reqforce", self.forceRepublishCb, qos_profile_system_default)
        self.create_subscription(Int32MultiArray, "reqRPM", self.rpmRepublishCb, qos_profile_system_default)

        self.rpmCommandPub = self.create_publisher(DshotCommand, "command/thruster_rpm", qos_profile_system_default)
        self.forceCommandPub = self.create_publisher(Float32MultiArray, "thruster_forces", qos_profile_system_default)

        #pub for thruster weights
        self.weightsPub = self.create_publisher(Int32MultiArray, THRUSTER_SOLVER_WEIGHT_MATRIX_TOPIC, qos_profile_system_default)

        #declare transform 
        self.tfBuffer = Buffer()
        self.tfListener = TransformListener(self.tfBuffer, self)

        #the tf namespace
        # TODO: FIX
        # self.tfNamespace = self.get_parameter("robot").value
        self.tfNamespace = "talos"

        #start time
        self.startTime = None

        #is the thrusterSolver active
        self.solverActive = False

        #is the ff controller
        self.ffActive = False

        #attempt to set the wrench matrix in the thruster solver
        self.create_timer(1.0, self.checkIfSimulinkActive)

        #publsh msgs at frequency
        self.pubRPMMsg = None
        self.pubForceMsg = None

        #start the publish loop
        self.create_timer(RPM_PUBLISH_PERIOD, self.pubCB)

        self.pubTimer = None
        self.enabled = True

        self.adjustThrusterWeights()

        self.calculateVolumeConstants()


    def thrusterTelemetryCB(self, msg: DshotPartialTelemetry):
        #wether or not the thrusterSolverweigths need adjusted
        adjustWeights = False

        # which thrusters - groups of 4
        if(msg.start_thruster_num == 0):
            #check wether each thruster is active
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.present:
                    if self.activeThrusters[i] == True:
                        #if change, adjust the thruster weights
                        self.activeThrusters[i] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i] == False:
                        self.activeThrusters[i] = True
                        adjustWeights = True
        else:
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.present:
                    if self.activeThrusters[i + 4] == True:
                        self.activeThrusters[i + 4] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i + 4] == False:
                        self.activeThrusters[i + 4] = True
                        adjustWeights = True

        #adjust the weights of the thruster solver if anything has changed
        if(adjustWeights):
            self.adjustThrusterWeights()

    def setThrusterModeCB(self, msg:Int16):
        #change the thruster mode

        #Modes -----
        #   1 - Normal
        #   2 - Low Downdraft

        if not (msg.data == self.thrusterMode):
            self.thrusterMode = msg.data

            #update the weights
            self.adjustThrusterWeights()
        
    def odometryCB(self, msg):
        #check if thrusters are submerged - everytime odom is updated - just using as a frequency 

        #start the start time on first cb
        if(self.startTime is None):
            self.startTime = self.get_clock().now()

        submerged = [False, False, False, False, False, False, False, False]

        try:
            #look at each thruster
            for i, thursterSufaced in enumerate(self.submerdgedThrusters):
                pos = self.tfBuffer.lookup_transform("world", f"{self.tfNamespace}/thruster_{i}", Time())

                #if thruster is above the kill plane
                if pos.transform.translation.z < self.killPlane:
                    submerged[i] = True
                            
            if not (np.array_equal(submerged, self.submerdgedThrusters)):
                #if a different thruster combo is submerdged, adjust, the weights
                self.submerdgedThrusters = submerged
                self.adjustThrusterWeights()
                
        except Exception as ex:
            if(self.get_clock().now().to_msg().sec >= ERROR_PATIENCE + self.startTime.to_msg().sec):
                self.get_logger().error("Thruster Position Lookup failed with exception: " + str(ex))
        
    def adjustThrusterWeights(self):
        #TODO add weight values into descriptions

        #number of active thrusters 
        activeThrusterCount = 0
        submerdgedThrusters = 0

        #shutoff inactive thrusters - disabled or broken
        for i, isActive in enumerate(self.activeThrusters):
            if(isActive):
                activeThrusterCount += 1

                #play around with weights for thrusters above surface
                if not (self.submerdgedThrusters[i] == True):
                    #if thruster is not submerdged
                    self.thrusterWeights[i] = self.surfaceWeight
                else:
                    #thruster is active and submerdged
                    submerdgedThrusters += 1
                    self.thrusterWeights[i] = self.defaultWeight

            else:
                #if a thruster is inactive - raise the cost of "using" thruster
                self.thrusterWeights[i] = self.disabledWeight
        
        if(activeThrusterCount <= 6):
            #if system is not full actuated, it cannot be optimized, very high rpms / force can be requested
            #for the safety of the system, this will autodisable robot (probably)
            #remove if PIA

            self.get_logger().error("System has become underactuated. Only:  " + str(activeThrusterCount) + " thrusters are active. Killing Thrusters!")
            self.enabled = False
        else:
            self.enabled = True
            
        if(submerdgedThrusters >= 8):
            #take into account control modes only if all actuators are working
            
            if(self.thrusterMode == 2):
                #apply low downdraft
                self.thrusterWeights[4] = self.lowDowndraftWeight
                self.thrusterWeights[5] = self.lowDowndraftWeight

        #impose disable weight if nessecary
        if(self.thrusterMode == 0):
            self.thrusterWeights = [0,0,0,0,0,0,0,0]

        msg = Int32MultiArray()

        #scale and round all weights
        weights = []
        for weight in self.thrusterWeights:
            weights.append(int(weight * PARAMETER_SCALE))   

        msg.data = weights

        #publish weights
        self.weightsPub.publish(msg)

    def calculateVolumeConstants(self):
        #calculate the buoyant force and cov

        self.talos_buoyant_force = (self.talos_mass * G - self.talos_base_wrench[2])

        #calculate cov delta from cob
        x = self.talos_base_wrench[4] / self.talos_base_wrench[2] + self.talos_COM[0]
        y = -self.talos_base_wrench[3] / self.talos_base_wrench[2] + self.talos_COM[1]
        z = -self.talos_face_up_wrench[1] / self.talos_face_up_wrench[4] + self.talos_COM[2]

        self.talos_COB = [x,y,z]

        #yaw compensation at central point
        self.talos_yaw_compensation = self.talos_base_wrench[5]

    def checkIfSimulinkActive(self):
        #attempt to set the wrench matrix in the simulink node

        foundSolver = False
        foundFF = False

        #see if the matlab node is running
        for nodeName in get_node_names(node=self):

            if nodeName.name == self.thrusterSolverName:
                foundSolver = True

            if nodeName.name == self.ffControllerName:
                foundFF = True

        if(self.solverActive != foundSolver):
            if(foundSolver):
                #thruster solver came online
                self.paramTimerTS = self.create_timer(1.0, self.setSolverParams)

                self.get_logger().info("Found Thruster Solver!")
            else:
                #lost thruster solver
                self.get_logger().error("Lost Thruster Solver!")

                #cancel the set default params operation
                self.paramTimerTS.cancel()

                #cancel the publishing
                self.pubTimer.cancel()

        if(self.ffActive != foundFF):
            if(foundFF):
                #thruster solver came online
                self.paramTimerFF = self.create_timer(1.0, self.setFFParams)

                self.get_logger().info("Found FF Controller Solver!")
            else:
                #lost thruster solver
                self.get_logger().error("Lost FF Controller Solver!")

                #cancel the set default params operation
                self.paramTimerFF.cancel()

                #cancel the publishing
                self.pubTimer.cancel()

        #update wether or not the solver has been found
        self.solverActive = foundSolver

        #update wether or not the ff controller is active
        self.ffActive = foundFF

    def setSolverParams(self):   
        self.get_logger().info("Setting Thruster Solver Default Parameters")

        #make the thruster effect matrix 1-D
        effects = []
        for thruster in self.thrusterEffects:
            for effect in thruster:
                effects.append(int(effect * PARAMETER_SCALE))

        val = ParameterValue()
        val.type = ParameterType.PARAMETER_INTEGER_ARRAY
        val.integer_array_value = effects

        param = Parameter()
        param.value = val
        param.name = THRUSTER_SOLVER_WRENCH_MATRIX_PARAM

        val1 = ParameterValue()
        val1.type = ParameterType.PARAMETER_INTEGER
        val1.integer_value = int(self.disabledWeight)

        param1 = Parameter()
        param1.value = val1
        param1.name = THRUSTER_SOLVER_DISABLE_WEIGHTS

        val2 = ParameterValue()
        val2.type = ParameterType.PARAMETER_INTEGER
        val2.integer_value = int(self.systemThrustLimit)

        param2 = Parameter()
        param2.value = val2
        param2.name = THRUSTER_SOLVER_SYSTEM_LIMIT_PARAM

        val3 = ParameterValue()
        val3.type = ParameterType.PARAMETER_INTEGER
        val3.integer_value = int(self.individualThrustLimit)

        param3 = Parameter()
        param3.value = val3
        param3.name = THRUSTER_SOLVER_INDIVIDUAL_LIMIT_PARAM

        val4 = ParameterValue()
        val4.type = ParameterType.PARAMETER_INTEGER
        val4.integer_value = PARAMETER_SCALE

        param4 = Parameter()
        param4.value = val4
        param4.name = THRUSTER_SOLVER_SCALING_PARAM

        #scale and round the coefficents
        coefficents = []
        for coefficent in self.forceToRPMCoefficents:
            coefficents.append(int(coefficent * PARAMETER_SCALE))

        val5 = ParameterValue()
        val5.type = ParameterType.PARAMETER_INTEGER_ARRAY
        val5.integer_array_value = coefficents

        param5 = Parameter()
        param5.value = val5
        param5.name = THRUSTER_SOLVER_FORCE_RPM_COEFFICENTS_PARAM

        #setup service request
        request = SetParameters.Request()
        request.parameters = [param, param1, param2, param3, param4, param5]

        self.future = self.setThrusterSolverParamsClient.call_async(request)

        #cancel the timer
        self.paramTimerTS.cancel()
        #ensure the pub timer is running if both models are active
        if(self.ffActive and self.solverActive):
            if(self.pubTimer is None):
                self.pubTimer = self.create_timer(RPM_PUBLISH_PERIOD, self.pubCB)
            elif(self.pubTimer.is_canceled()):
                self.pubTimer = self.create_timer(RPM_PUBLISH_PERIOD, self.pubCB)

    def setFFParams(self):   
        self.get_logger().info("Setting FF Contoller Default Parameters")

        val = ParameterValue()
        val.type = ParameterType.PARAMETER_INTEGER
        val.integer_value = 1000000

        param = Parameter()
        param.value = val
        param.name = FF_CONTROLLER_SCALING_PARAM

        cobValues = []
        for val in self.talos_COB:
            cobValues.append(int(PARAMETER_SCALE * val))

        val1 = ParameterValue()
        val1.type = ParameterType.PARAMETER_INTEGER_ARRAY
        val1.integer_array_value = cobValues

        param1 = Parameter()
        param1.value = val1
        param1.name = FF_CONTROLLER_COB_PARAM

        comValues = []
        for val in self.talos_COM:
            comValues.append(int(PARAMETER_SCALE * val))

        val2 = ParameterValue()
        val2.type = ParameterType.PARAMETER_INTEGER_ARRAY
        val2.integer_array_value = comValues

        param2 = Parameter()
        param2.value = val2
        param2.name = FF_CONTROLLER_COM_PARAM

        val3 = ParameterValue()
        val3.type = ParameterType.PARAMETER_INTEGER
        val3.integer_value = int(self.talos_buoyant_force * PARAMETER_SCALE)

        param3 = Parameter()
        param3.value = val3
        param3.name = FF_CONTROLLER_BUOYANT_FORCE_PARAM

        val4 = ParameterValue()
        val4.type = ParameterType.PARAMETER_INTEGER
        val4.integer_value = int(self.talos_mass * PARAMETER_SCALE)

        param4 = Parameter()
        param4.value = val4
        param4.name = FF_CONTROLLER_MASS_PARAM

        val5 = ParameterValue()
        val5.type = ParameterType.PARAMETER_INTEGER
        val5.integer_value = int(self.talos_yaw_compensation * PARAMETER_SCALE)

        param5 = Parameter()
        param5.value = val5
        param5.name = FF_CONTROLLER_YAW_COMPENSATION_PARAM

        #setup service request
        request = SetParameters.Request()
        request.parameters = [param, param1, param2, param3, param4, param5]

        self.future = self.setFFControllerParamsClient.call_async(request)

        #cancel the timer
        self.paramTimerFF.cancel()
        #ensure the pub timer is running if both models are active
        if(self.ffActive and self.solverActive):
            if(self.pubTimer is None):
                self.pubTimer = self.create_timer(RPM_PUBLISH_PERIOD, self.pubCB)
            elif(self.pubTimer.is_canceled()):
                self.pubTimer = self.create_timer(RPM_PUBLISH_PERIOD, self.pubCB)


    #remove once matlab publishes to correct message
    def forceRepublishCb(self, msg:Int32MultiArray):
        #the message to republish to
        pub_msg = Float32MultiArray()
                
        if(len(msg.data) == 8):
            for datum in msg.data:
                #scale by .000001
                pub_msg.data.append(datum * .000001)


            #publish the message
            self.pubForceMsg = pub_msg
        else:
            self.get_logger().warn("Forces form solver has wrong length of: " + str(len(msg.data)))

    #remove once matlab publishes to correct message
    def rpmRepublishCb(self, msg:Int32MultiArray):
        #the message to republish to
        pub_msg = DshotCommand()
        
        if(len(msg.data) == 8):
            for i, datum in enumerate(msg.data):
                #scale by .000001
                pub_msg.values[i] = (datum)


            self.pubRPMMsg = pub_msg
        else:
            self.get_logger().warn("RPM form solver has wrong length of: " + str(len(msg.data)))

    def pubCB(self):
        #publish rpms
        if(self.enabled):
            if(self.pubForceMsg is not None):
                self.forceCommandPub.publish(self.pubForceMsg)

            if(self.pubRPMMsg is not None):
                self.rpmCommandPub.publish(self.pubRPMMsg)

def main(args=None):
    rclpy.init(args=args)

    co = controllerOverseer()

    rclpy.spin(co)

if __name__ == '__main__':
    main()

            
