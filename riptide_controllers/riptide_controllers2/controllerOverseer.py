import rclpy
from rclpy.node import Node
from rclpy.qos import qos_profile_services_default, qos_profile_system_default

from tf_transformations import euler_matrix

import numpy as np

import yaml

from riptide_msgs2.msg import DshotPartialTelemetry, KillSwitchReport
from nav_msgs.msg import Odometry
from rcl_interfaces.srv import SetParameters
from rcl_interfaces.msg import Parameter, ParameterValue
from std_msgs.msg import Int16

#manages parameters for the controller / thruster solver

class controllerOverseer(Node):

    def __init__(self):
        super().__init__("controllerOverseer")

        #get robot name 
        self.declare_parameter("robot", "")
        self.robotName = self.get_parameter("robot").value

        #get robot config file path
        self.declare_parameter("vehicle_config", "")
        config_path = self.get_parameter("vehicle_config").value
        if(config_path == ''):
            #remove before running on robot
            config_path = "src/riptide_core/riptide_descriptions/config/talos.yaml"

            #self.get_logger().fatal("Controller Overseer: cannot find vehicle configuration file!")

        #open configuration file
        with open(config_path, "r") as config:
            config_file = yaml.safe_load(config)

        #read in thruster pose data
        thruster_info = config_file['thrusters']

        #generate the thruster effect matrix
        thrusterEffects = np.zeros(shape=(8,6))
        for i, thruster in enumerate(thruster_info):
            pose = np.array(thruster["pose"])

            #calculate the force vector generated by the thruster
            forceVector = np.matmul(euler_matrix(pose[3], pose[4], pose[5])[:3, :3], np.array([1,0,0]))
            torque = np.cross(pose[:3], forceVector)

            #insert into thruster effect matrix
            thrusterEffects[i] = [forceVector[0], forceVector[1], forceVector[2], torque[0], torque[1], torque[2]]

        #default thruster weights and working thrusters
        self.activeThrusters = [True, True, True, True, True, True, True, True]
        self.submerdgedThrusters = [True, True, True, True, True, True, True, True]
        self.thrusterWeights = [1,1,1,1,1,1,1,1]

        # the thruster mode
        self.thrusterMode = 1

        #declare pubs and subs

        #thruster telemetry
        self.create_subscription(DshotPartialTelemetry, "state/thrusters/telemetry", self.thrusterTelemetryCB, qos_profile_system_default)
        #thruster Weights
        self.thrusterWeightsClient = self.create_client(SetParameters, "thrusterSolver/set_parameters", qos_profile_services_default)
        #thruster mode
        self.create_subscription(Int16, "thrusterSolver/thrusterState", )
        #software kill 
        self.killPub = self.create_publisher(KillSwitchReport, "command/software_kill", qos_profile_system_default)
        #odometry filtered
        self.create_subscription(Odometry, "odometry/filtered", self.odometryCB, qos_profile_system_default)

    def thrusterTelemetryCB(self, msg: DshotPartialTelemetry):
        #wether or not the thrusterSolverweigths need adjusted
        adjustWeights = False

        # which thrusters - groups of 4
        if(msg.start_thruster_num == 0):
            #check wether each thruster is active
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.present:
                    if self.activeThrusters[i] == True:
                        #if change, adjust the thruster weights
                        self.activeThrusters[i] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i] == False:
                        self.activeThrusters[i] = True
                        adjustWeights = True
        else:
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.present:
                    if self.activeThrusters[i + 4] == True:
                        self.activeThrusters[i + 4] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i + 4] == False:
                        self.activeThrusters[i + 4] = True
                        adjustWeights = True

        #adjust the weights of the thruster solver if anything has changed
        if(adjustWeights):
            self.adjustThrusterWeights()

    def setThrusterModeCB(self, msg:Int16):
        #change the thruster mode

        #Modes -----
        #   1 - Normal
        #   2 - Low Downdraft

        if not (msg.data == self.thrusterMode):
            self.thrusterMode = msg.data

            #update the weights
            self.adjustThrusterWeights()
        
    def odometryCB(self, msg):
        #check if thrusters are submerged

    def adjustThrusterWeights(self):
        #TODO add weight values into descriptions

        #number of active thrusters 
        activeThrusterCount = 0
        submerdgedThrusters = 0

        #shutoff inactive thrusters - disabled or broken
        for i, isActive in self.activeThrusters:
            if(isActive):
                activeThrusterCount += 1

                #play around with weights for thrusters above surface
                if not (self.submerdgedThrusters[i] == True):
                    #if thruster is not submerdged
                    self.thrusterWeights[i] = 4
                else:
                    #thruster is active and submerdged
                    submerdgedThrusters += 1
                    self.thrusterWeights = 1

            else:
                #if a thruster is inactive - raise the cost of "using" thruster
                self.thrusterWeights[i] = 999999
        
        if(activeThrusterCount <= 6):
            #if system is not full actuated, it cannot be optimized, very high rpms / force can be requested
            #for the safety of the system, this will autodisable robot (probably)
            #remove if PIA

            self.get_logger().error("System has become underactuated. Only:  " + str(activeThrusterCount) + " thrusters are active. Killing Thrusters!")
            
            #add a kill switch report
            msg = KillSwitchReport()
            msg.sender_id = self.get_name()
            msg.kill_switch_id = 3 # this is the debug switch - ask firmware to fix
            msg.switch_asserting_kill = True
            msg.switch_needs_update = True

            self.killPub.publish(msg)
            
        if(submerdgedThrusters >= 8):
            #take into account control modes only if all actuators are working
            
            if(self.thrusterMode == 2):
                #apply low downdraft
                self.thrusterWeights[4] = 3
                self.thrusterWeights[5] = 3
                

        #declare the weight paramter value
        paramValue = ParameterValue()
        ParameterValue.type = 7 # i think...
        ParameterValue.double_array_value = self.thrusterWeights

        param = Parameter()
        param.name = "ThrusterWeights"
        param.value = paramValue

        #setup service request
        request = SetParameters()
        request.paramters = [param]

        self.thrusterWeightsClient.call_async(request)



def main(args=None):
    rclpy.init(args=args)

    co = controllerOverseer()

    rclpy.spin(co)

if __name__ == '__main__':
    main()

            
