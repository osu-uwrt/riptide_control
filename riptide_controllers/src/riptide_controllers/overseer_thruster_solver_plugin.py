import numpy as np
from rclpy.node import Node
from rclpy.qos import qos_profile_system_default
from rclpy.time import Time
from tf_transformations import euler_matrix
from tf2_ros import TransformListener, Buffer
from std_msgs.msg import Int16, Bool, Int32MultiArray
from nav_msgs.msg import Odometry
from riptide_msgs2.msg import DshotPartialTelemetry

from overseer_global_defs import ESC_POWER_TIMEOUT, WEIGHTS_FORCE_UPDATE_PERIOD, ESC_POWER_STOP_TOLERANCE, ERROR_PATIENCE
from controller_overseer import SimulinkModelNode

class OverseerThrusterSolverPlugin:
    def __init__(self):
        pass
    
    
    def init_plugin(self, rosnode: Node, config, model: SimulinkModelNode):
        self.enabled = True
        self.rosnode = rosnode
        self.escPowerStopsLow = 0
        self.escPowerStopsHigh = 0
        self.startTime = None
        
        self.thruster_info = config['thrusters']
        self.com = config["com"]
        self.killPlane = config["controller_overseer"]["thruster_kill_plane"]
        
        #read in weight info
        thruster_solver_info    = config["thruster_solver"]
        self.defaultWeight      = thruster_solver_info["default_weight"]
        self.surfaceWeight      = thruster_solver_info["surfaced_weight"]
        self.disabledWeight     = thruster_solver_info["disable_weight"]
        self.lowDowndraftWeight = thruster_solver_info["low_downdraft_weight"]
        
        #generate the thruster effect matrix
        self.thrusterEffects = np.zeros(shape=(8,6))
        for i, thruster in enumerate(self.thruster_info):
            pose = np.array(thruster["pose"])

            #calculate the force vector generated by the thruster
            forceVector = np.matmul(euler_matrix(pose[3], pose[4], pose[5])[:3, :3], np.array([1,0,0]))
            positionFromCOM = pose[:3] - self.com
            torque = np.cross(positionFromCOM[:3], forceVector)

            #insert into thruster effect matrix
            self.thrusterEffects[i] = [forceVector[0], forceVector[1], forceVector[2], torque[0], torque[1], torque[2]]
            
        self.activeThrusters = [True, True, True, True, True, True, True, True]
        self.submergedThrusters = [True, True, True, True, True, True, True, True]
        self.thrusterWeights = [1, 1, 1, 1, 1, 1, 1, 1]
        self.thrusterMode = 1
        
        self.motionEnabledPub = rosnode.create_publisher(Bool, "controller/motion_enabled", qos_profile=qos_profile_system_default)
        self.weightsPub = rosnode.create_publisher(Int32MultiArray, "controller/solver_weights", qos_profile_system_default)
        
        rosnode.create_subscription(Odometry, "odometry/filtered", self.odometryCB, qos_profile_system_default)
        rosnode.create_subscription(DshotPartialTelemetry, "state/thrusters/telemetry", self.thrusterTelemetryCB, qos_profile_system_default)
        rosnode.create_subscription(Int16, "thrusterSolver/thrusterState", self.setThrusterModeCB, qos_profile_system_default)
        
        self.tfBuffer = Buffer()
        self.tfListener = TransformListener(self.tfBuffer, rosnode)
        
        #the tf namespace
        # TODO: FIX
        # self.tfNamespace = self.get_parameter("robot").value
        self.tfNamespace = "talos"
        
        # a timer to ensure that the active controllers stop if telemetry stops publishing!
        self.escPowerCheckTimer = rosnode.create_timer(ESC_POWER_TIMEOUT, self.escPowerTimeout)
        rosnode.create_timer(WEIGHTS_FORCE_UPDATE_PERIOD, self.adjustThrusterWeights)
        
    
    def thrusterTelemetryCB(self, msg: DshotPartialTelemetry):
        #wether or not the thrusterSolverweigths need adjusted
        adjustWeights = False

        #restart the timeout
        self.escPowerCheckTimer.reset()

        # which thrusters - groups of 4
        if msg.start_thruster_num == 0:
            #check wether each thruster is active
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.thruster_ready:
                    if self.activeThrusters[i] == True:
                        #if change, adjust the thruster weights
                        self.activeThrusters[i] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i] == False:
                        self.activeThrusters[i] = True
                        adjustWeights = True

            #check if the boards are enebaled
            if not (msg.disabled_flags == 0):  
                self.escPowerStopsLow += 1    
            else:
                self.escPowerStopsLow = 0 

        else:
            for i, esc in enumerate(msg.esc_telemetry):
                if not esc.thruster_ready:
                    if self.activeThrusters[i + 4] == True:
                        self.activeThrusters[i + 4] = False
                        adjustWeights = True
                else:
                    if self.activeThrusters[i + 4] == False:
                        self.activeThrusters[i + 4] = True
                        adjustWeights = True

            #check if the boards are enebaled
            if not (msg.disabled_flags == 0):  
                self.escPowerStopsHigh += 1  
            else:
                self.escPowerStopsHigh = 0     

        #adjust the weights of the thruster solver if anything has changed
        if adjustWeights:
            self.adjustThrusterWeights()

        motionMsg = Bool()
        #check if the boards are enebaled
        if self.escPowerStopsLow > ESC_POWER_STOP_TOLERANCE or self.escPowerStopsHigh > ESC_POWER_STOP_TOLERANCE:
            #publish disabled message
            motionMsg.data = False
            self.enabled = False

            # if self.enabled:
            #     self.get_logger().warn("Recieving disabled flags from ESC!")
        else:

            motionMsg.data = True
            self.enabled = True
            #publish enabled message
        
        self.motionEnabledPub.publish(motionMsg)
        
    
    def odometryCB(self, msg):
        #check if thrusters are submerged - everytime odom is updated - just using as a frequency

        #start the start time on first cb
        if self.startTime is None:
            self.startTime = self.rosnode.get_clock().now()

        submerged = [False, False, False, False, False, False, False, False]

        try:
            #look at each thrusterbreak
            for i, thursterSufaced in enumerate(self.submergedThrusters):
                pos = self.tfBuffer.lookup_transform("world", f"{self.tfNamespace}/thruster_{i}", Time())

                #if thruster is above the kill plane
                if pos.transform.translation.z < self.killPlane:
                    submerged[i] = True

            if not (np.array_equal(submerged, self.submergedThrusters)):
                #if a different thruster combo is submerdged, adjust, the weights
                self.submergedThrusters = submerged
                self.adjustThrusterWeights()

        except Exception as ex:
            if self.rosnode.get_clock().now().to_msg().sec >= ERROR_PATIENCE + self.startTime.to_msg().sec:
                self.rosnode.get_logger().error("Thruster Position Lookup failed with exception: " + str(ex))
    
    
    def adjustThrusterWeights(self):
        #TODO add weight values into descriptions

        #number of active thrusters
        activeThrusterCount = 0
        submergedThrusters = 0

        #shutoff inactive thrusters - disabled or broken
        for i, isActive in enumerate(self.activeThrusters):
            if isActive:
                activeThrusterCount += 1

                #play around with weights for thrusters above surface
                if not (self.submergedThrusters[i] == True):
                    #if thruster is not submerdged
                    self.thrusterWeights[i] = self.surfaceWeight
                else:
                    #thruster is active and submerdged
                    submergedThrusters += 1
                    self.thrusterWeights[i] = self.defaultWeight

            else:
                #if a thruster is inactive - raise the cost of "using" thruster
                self.thrusterWeights[i] = self.disabledWeight

        if activeThrusterCount <= 6:
            #if system is not full actuated, it cannot be optimized, very high rpms / force can be requested
            #for the safety of the system, this will autodisable robot (probably)
            #remove if PIA
            if self.enabled:
                self.rosnode.get_logger().error("System has become underactuated. Only:  " + str(activeThrusterCount) + " thrusters are active. Killing Thrusters!")
                self.enabled = False
        else:
            self.enabled = True

        if submergedThrusters >= 8:
            #take into account control modes only if all actuators are working

            if self.thrusterMode == 2:
                #apply low downdraft
                self.thrusterWeights[4] = self.lowDowndraftWeight
                self.thrusterWeights[5] = self.lowDowndraftWeight

        #impose disable weight if nessecary
        if self.thrusterMode == 0:
            self.thrusterWeights = [0,0,0,0,0,0,0,0]

        msg = Int32MultiArray()

        #scale and round all weights
        weights = []
        for weight in self.thrusterWeights:
            weights.append(int(weight))

        msg.data = weights

        #publish weights
        self.weightsPub.publish(msg)
    
    def get1dWrenchmat(self):
        #change to 1D array
        effects_1D = []
        for column in self.thrusterEffects:
            for effect in column:
                effects_1D.append(effect)

        return effects_1D, list
        
    
    def setThrusterModeCB(self, msg:Int16):
        #change the thruster mode

        #Modes -----
        #   1 - Normal
        #   2 - Low Downdraft

        if not (msg.data == self.thrusterMode):
            self.thrusterMode = msg.data

            #update the weights
            self.adjustThrusterWeights()
            
            
    def escPowerTimeout(self):
        #timeout for if the escs go to long without publishing telemerty
        if self.enabled:
            self.rosnode.get_logger().warn("Not recieving thruster telemetry!")

        motionMsg = Bool()
        motionMsg.data = False
        self.enabled = False
        self.motionEnabledPub.publish(motionMsg)

def get_plugin():
    return OverseerThrusterSolverPlugin()
